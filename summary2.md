# Generated by ContextBuilder
# 项目源码分析文档 (按配置)

--- AI Interaction Instructions ---
        为您呈现的是一个项目的完整源代码快照(或部分特定项目组件的源码快照)，它采用了一种名为 "LineMark" 的系统进行精确引用。

        **LineMark 格式:**
        代码的每一行都带有一个 `[FileID:LineNumber]|` 格式的前缀。
        - `FileID`: 一个简短的标识符 (如 F1, F2)，它唯一地对应一个完整的文件路径。
        - `LineNumber`: 该行在特定文件中的行号。
        - `|`: (竖线后跟一个空格)标记与原始代码内容的分隔符。

        **您的任务:**
        在您的所有回答中，您必须使用此 LineMark 格式来引用具体的代码位置。例如:
        - "我建议重构 `[F5:23-28]` 中的逻辑。"
        - "在 `[F12:101]` 中可能存在一个潜在的bug。"
        - 若要新增代码，请这样描述: "在 `[F3:45]` 之后，插入以下代码: ..."

        这个系统确保了我们之间沟通的绝对精确性。FileID到文件路径的完整映射关系在下方的 "LineMark Manifest" 中提供。
        ---------------------------------

--- LineMark Manifest ---
F1: queue_utils.py
F2: scheduler.sh
F3: tq.py
F4: uninstall.sh
F5: setup.sh
F6: examples/demo_task.py
F7: tests/test_core.py
F8: tests/test_env_features.py
F9: tests/test_v5_7_features.py
F10: tests/test_grace_logging.py
-----------------------
- 配置文件: context_config.yaml

## 项目文件结构
```
├── examples/
    └── demo_task.py
├── tests/
    ├── test_core.py
    ├── test_env_features.py
    ├── test_grace_logging.py
    └── test_v5_7_features.py
├── queue_utils.py
├── scheduler.sh
├── setup.sh
├── tq.py
└── uninstall.sh
```

## 源代码文件内容

################################################################################
文件路径: queue_utils.py(F1) (约合大小: 1 KB)
################################################################################
[F1:1]| #!/usr/bin/env python3
[F1:2]| import sys
[F1:3]| import os
[F1:4]| 
[F1:5]| def pop_best_task(queue_file):
[F1:6]|     """
[F1:7]|     读取队列文件，按优先级排序，移除并返回优先级最高的任务。
[F1:8]|     """
[F1:9]|     if not os.path.exists(queue_file):
[F1:10]|         return None
[F1:11]|     
[F1:12]|     try:
[F1:13]|         with open(queue_file, 'r') as f:
[F1:14]|             # 过滤空行
[F1:15]|             lines = [l.strip() for l in f.readlines() if l.strip()]
[F1:16]|         
[F1:17]|         if not lines:
[F1:18]|             return None
[F1:19]| 
[F1:20]|         # 排序：按冒号分隔的第一个字段(优先级)排序
[F1:21]|         # 格式: Prio:Grace:Cmd
[F1:22]|         # lambda 保护：如果格式不对，默认优先级放最后
[F1:23]|         lines.sort(key=lambda x: int(x.split(':')[0]) if ':' in x else 99999)
[F1:24]| 
[F1:25]|         # 弹出第一个
[F1:26]|         best_task = lines.pop(0)
[F1:27]| 
[F1:28]|         # 写回文件
[F1:29]|         with open(queue_file, 'w') as f:
[F1:30]|             if lines:
[F1:31]|                 f.write('\n'.join(lines) + '\n')
[F1:32]|             else:
[F1:33]|                 f.write('') # 清空
[F1:34]|         
[F1:35]|         return best_task
[F1:36]| 
[F1:37]|     except Exception as e:
[F1:38]|         # 出错时不破坏文件，直接返回空
[F1:39]|         return None
[F1:40]| 
[F1:41]| def get_min_priority(queue_file):
[F1:42]|     """
[F1:43]|     只获取当前队列中最高的优先级数值，不修改文件。
[F1:44]|     用于抢占判断。
[F1:45]|     """
[F1:46]|     if not os.path.exists(queue_file):
[F1:47]|         print(99999)
[F1:48]|         return
[F1:49]| 
[F1:50]|     try:
[F1:51]|         with open(queue_file, 'r') as f:
[F1:52]|             lines = [l.strip() for l in f.readlines() if l.strip()]
[F1:53]|         
[F1:54]|         if not lines:
[F1:55]|             print(99999)
[F1:56]|             return
[F1:57]| 
[F1:58]|         min_p = min(int(l.split(':')[0]) for l in lines if ':' in l)
[F1:59]|         print(min_p)
[F1:60]|     except:
[F1:61]|         print(99999)
[F1:62]| 
[F1:63]| if __name__ == "__main__":
[F1:64]|     if len(sys.argv) < 3:
[F1:65]|         sys.exit(1)
[F1:66]|     
[F1:67]|     action = sys.argv[1]
[F1:68]|     q_file = sys.argv[2]
[F1:69]| 
[F1:70]|     if action == "pop":
[F1:71]|         task = pop_best_task(q_file)
[F1:72]|         if task:
[F1:73]|             print(task)
[F1:74]|             sys.exit(0)
[F1:75]|         else:
[F1:76]|             sys.exit(1)
[F1:77]|             
[F1:78]|     elif action == "peek_prio":
[F1:79]|         get_min_priority(q_file)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
文件路径: scheduler.sh(F2) (约合大小: 5 KB)
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
[F2:1]| #!/bin/bash
[F2:2]| # =========================================================
[F2:3]| # 通用资源调度器 (v5.7 - Tag Support & Log Headers)
[F2:4]| # =========================================================
[F2:5]| 
[F2:6]| set -m
[F2:7]| 
[F2:8]| if [ -z "$1" ]; then exit 1; fi
[F2:9]| 
[F2:10]| QUEUE_NAME="$1"
[F2:11]| BASE_DIR="$HOME/task_queue" 
[F2:12]| QUEUE_FILE="$BASE_DIR/${QUEUE_NAME}.queue"
[F2:13]| RUNNING_FILE="$BASE_DIR/${QUEUE_NAME}.running"
[F2:14]| LOG_FILE="$BASE_DIR/logs/scheduler_${QUEUE_NAME}.log"
[F2:15]| LOCK_FILE="/tmp/scheduler_${QUEUE_NAME}.lock"
[F2:16]| TASK_LOG_DIR="$BASE_DIR/logs/tasks"
[F2:17]| UTILS_SCRIPT="$BASE_DIR/queue_utils.py"
[F2:18]| 
[F2:19]| if [[ "$QUEUE_NAME" =~ ^[0-9,]+$ ]]; then
[F2:20]|     IS_GPU_MODE=true
[F2:21]|     GPU_ID="$QUEUE_NAME"
[F2:22]| else
[F2:23]|     IS_GPU_MODE=false
[F2:24]| fi
[F2:25]| 
[F2:26]| mkdir -p "$BASE_DIR/logs" "$TASK_LOG_DIR"
[F2:27]| touch "$QUEUE_FILE"
[F2:28]| 
[F2:29]| if [ -e "$LOCK_FILE" ]; then
[F2:30]|     EXISTING_PID=$(cat "$LOCK_FILE")
[F2:31]|     if kill -0 "$EXISTING_PID" 2>/dev/null; then
[F2:32]|         echo "[ERROR] Already running."
[F2:33]|         exit 1
[F2:34]|     else
[F2:35]|         rm -f "$LOCK_FILE"
[F2:36]|     fi
[F2:37]| fi
[F2:38]| echo $$ > "$LOCK_FILE"
[F2:39]| trap 'rm -f "$LOCK_FILE"; exit' INT TERM EXIT
[F2:40]| 
[F2:41]| log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$QUEUE_NAME] $1" >> "$LOG_FILE"; }
[F2:42]| 
[F2:43]| if [ "$IS_GPU_MODE" = true ]; then log "INFO: GPU MODE ($GPU_ID)."; else log "INFO: GENERIC MODE."; fi
[F2:44]| 
[F2:45]| terminate_task() {
[F2:46]|     local pid="$1"
[F2:47]|     local grace="$2"
[F2:48]|     if ! ps -p "$pid" > /dev/null; then return; fi
[F2:49]|     log "KILL: Sending SIGTERM to -$pid (Grace: ${grace}s)"
[F2:50]|     kill -SIGTERM -- -"$pid" 2>/dev/null
[F2:51]|     
[F2:52]|     local counter=0
[F2:53]|     local max_checks=$((grace / 2))
[F2:54]|     while ps -p "$pid" > /dev/null; do
[F2:55]|         sleep 2
[F2:56]|         ((counter++))
[F2:57]|         if [ "$counter" -ge "$max_checks" ]; then
[F2:58]|             log "KILL: Timeout. SIGKILL."
[F2:59]|             kill -SIGKILL -- -"$pid" 2>/dev/null
[F2:60]|             break
[F2:61]|         fi
[F2:62]|     done
[F2:63]| }
[F2:64]| 
[F2:65]| while true; do
[F2:66]|     managed_pid=""
[F2:67]|     if [ -f "$RUNNING_FILE" ]; then
[F2:68]|         managed_pid=$(head -n 1 "$RUNNING_FILE")
[F2:69]|         if ! ps -p "$managed_pid" > /dev/null; then
[F2:70]|             log "CLEANUP: Task $managed_pid finished naturally."
[F2:71]|             rm -f "$RUNNING_FILE"
[F2:72]|             managed_pid=""
[F2:73]|         fi
[F2:74]|     fi
[F2:75]| 
[F2:76]|     unmanaged_pid=""
[F2:77]|     if [ "$IS_GPU_MODE" = true ]; then
[F2:78]|         gpu_pids=$(nvidia-smi --query-compute-apps=pid --format=csv,noheader,nounits -i "$GPU_ID" 2>/dev/null)
[F2:79]|         for pid in $gpu_pids; do
[F2:80]|             if [ -n "$pid" ] && [ "$pid" != "$managed_pid" ]; then
[F2:81]|                 unmanaged_pid=$pid
[F2:82]|                 break
[F2:83]|             fi
[F2:84]|         done
[F2:85]|     fi
[F2:86]| 
[F2:87]|     # A: Yield
[F2:88]|     if [ -n "$unmanaged_pid" ]; then
[F2:89]|         if [ -n "$managed_pid" ]; then
[F2:90]|             log "YIELD: Unmanaged PID $unmanaged_pid."
[F2:91]|             curr_prio=$(sed -n '2p' "$RUNNING_FILE")
[F2:92]|             curr_grace=$(sed -n '3p' "$RUNNING_FILE")
[F2:93]|             curr_tag=$(sed -n '4p' "$RUNNING_FILE") # 从文件读取 Tag
[F2:94]|             curr_cmd=$(sed -n '6p' "$RUNNING_FILE") # Cmd is now line 6
[F2:95]|             
[F2:96]|             terminate_task "$managed_pid" "$curr_grace"
[F2:97]|             # 保留原始 Tag
[F2:98]|             echo "${curr_prio}:${curr_grace}:${curr_tag}:${curr_cmd}" >> "$QUEUE_FILE"
[F2:99]|             rm -f "$RUNNING_FILE"
[F2:100]|         fi
[F2:101]|         sleep 10
[F2:102]|         continue
[F2:103]| 
[F2:104]|     # B: Preempt
[F2:105]|     elif [ -f "$RUNNING_FILE" ] && [ -s "$QUEUE_FILE" ]; then
[F2:106]|         curr_prio=$(sed -n '2p' "$RUNNING_FILE")
[F2:107]|         best_prio=$(python3 "$UTILS_SCRIPT" peek_prio "$QUEUE_FILE")
[F2:108]|         
[F2:109]|         if [ "$best_prio" -lt "$curr_prio" ]; then
[F2:110]|             log "PREEMPT: Queue($best_prio) > Current($curr_prio)."
[F2:111]|             curr_grace=$(sed -n '3p' "$RUNNING_FILE")
[F2:112]|             curr_tag=$(sed -n '4p' "$RUNNING_FILE")
[F2:113]|             curr_cmd=$(sed -n '6p' "$RUNNING_FILE")
[F2:114]|             
[F2:115]|             terminate_task "$managed_pid" "$curr_grace"
[F2:116]|             # 保留原始 Tag
[F2:117]|             echo "${curr_prio}:${curr_grace}:${curr_tag}:${curr_cmd}" >> "$QUEUE_FILE"
[F2:118]|             rm -f "$RUNNING_FILE"
[F2:119]|             continue
[F2:120]|         fi
[F2:121]| 
[F2:122]|     # C: Start
[F2:123]|     elif [ ! -f "$RUNNING_FILE" ] && [ -s "$QUEUE_FILE" ]; then
[F2:124]|         best_line=$(python3 "$UTILS_SCRIPT" pop "$QUEUE_FILE")
[F2:125]|         if [ -z "$best_line" ]; then sleep 1; continue; fi
[F2:126]| 
[F2:127]|         best_prio=$(echo "$best_line" | cut -d: -f1)
[F2:128]|         best_grace=$(echo "$best_line" | cut -d: -f2)
[F2:129]|         best_tag=$(echo "$best_line" | cut -d: -f3)
[F2:130]|         best_cmd=$(echo "$best_line" | cut -d: -f4-)
[F2:131]|         
[F2:132]|         if [ -z "$best_cmd" ]; then # 兼容旧数据
[F2:133]|             best_cmd=$best_tag
[F2:134]|             best_tag="default"
[F2:135]|         fi
[F2:136]| 
[F2:137]|         # 安全过滤 Tag
[F2:138]|         safe_tag=$(echo "$best_tag" | sed 's/[^a-zA-Z0-9._-]/_/g')
[F2:139]| 
[F2:140]|         TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
[F2:141]|         TASK_LOG_FILE="$TASK_LOG_DIR/${QUEUE_NAME}_${TIMESTAMP}_${safe_tag}.log"
[F2:142]|         
[F2:143]|         log "START: Task (Prio: $best_prio, Tag: $best_tag). Output -> $TASK_LOG_FILE"
[F2:144]|         
[F2:145]|         # Write Header
[F2:146]|         {
[F2:147]|             echo "=========================================="
[F2:148]|             echo " Task Metadata Log"
[F2:149]|             echo "=========================================="
[F2:150]|             echo " Start Time : $(date)"
[F2:151]|             echo " Queue      : $QUEUE_NAME"
[F2:152]|             echo " Tag        : $best_tag"
[F2:153]|             echo " Priority   : $best_prio"
[F2:154]|             echo " Grace      : ${best_grace}s"
[F2:155]|             echo " Command    : $best_cmd"
[F2:156]|             echo "=========================================="
[F2:157]|             echo ""
[F2:158]|             echo ">>> Task Output Follows >>>"
[F2:159]|             echo ""
[F2:160]|         } > "$TASK_LOG_FILE"
[F2:161]| 
[F2:162]|         if [ "$IS_GPU_MODE" = true ]; then
[F2:163]|             (export CUDA_VISIBLE_DEVICES=$GPU_ID; eval "$best_cmd") >> "$TASK_LOG_FILE" 2>&1 &
[F2:164]|         else
[F2:165]|             (eval "$best_cmd") >> "$TASK_LOG_FILE" 2>&1 &
[F2:166]|         fi
[F2:167]|         
[F2:168]|         new_pid=$!
[F2:169]|         # 写入 6 行: PID, Prio, Grace, Tag, LogPath, Cmd
[F2:170]|         echo -e "$new_pid\n$best_prio\n$best_grace\n$best_tag\n$TASK_LOG_FILE\n$best_cmd" > "$RUNNING_FILE"
[F2:171]|     fi
[F2:172]| 
[F2:173]|     sleep 3
[F2:174]| done

################################################################################
文件路径: tq.py(F3) (约合大小: 16 KB)
################################################################################
[F3:1]| #!/usr/bin/env python3
[F3:2]| import cmd
[F3:3]| import os
[F3:4]| import sys
[F3:5]| import re
[F3:6]| import glob
[F3:7]| import time
[F3:8]| import datetime
[F3:9]| import readline
[F3:10]| import rlcompleter
[F3:11]| import fcntl 
[F3:12]| 
[F3:13]| BASE_DIR = os.path.expanduser("~/task_queue")
[F3:14]| LOG_DIR = os.path.join(BASE_DIR, "logs")
[F3:15]| TASK_LOG_DIR = os.path.join(LOG_DIR, "tasks")
[F3:16]| SCHEDULER_SCRIPT = os.path.join(BASE_DIR, "scheduler.sh")
[F3:17]| 
[F3:18]| class TaskQueueShell(cmd.Cmd):
[F3:19]|     intro = 'Welcome to Task Queue Console v5.7 (Refined).\nType "man" for help.'
[F3:20]|     
[F3:21]|     def __init__(self):
[F3:22]|         super().__init__()
[F3:23]|         self.current_queue = "0"
[F3:24]|         self.ensure_dirs()
[F3:25]|         self.conda_env = os.environ.get("CONDA_DEFAULT_ENV", "base")
[F3:26]|         self.history_cache = [] 
[F3:27]|         self.update_prompt()
[F3:28]|         if 'libedit' in readline.__doc__: readline.parse_and_bind("bind ^I rl_complete")
[F3:29]|         else: readline.parse_and_bind("tab: complete")
[F3:30]| 
[F3:31]|     def ensure_dirs(self):
[F3:32]|         for d in [BASE_DIR, LOG_DIR, TASK_LOG_DIR]:
[F3:33]|             if not os.path.exists(d): os.makedirs(d)
[F3:34]| 
[F3:35]|     def _is_active(self, queue_name):
[F3:36]|         lock_file = f"/tmp/scheduler_{queue_name}.lock"
[F3:37]|         if os.path.exists(lock_file):
[F3:38]|             try:
[F3:39]|                 with open(lock_file, 'r') as f: pid = int(f.read().strip())
[F3:40]|                 os.kill(pid, 0)
[F3:41]|                 return True
[F3:42]|             except: return False
[F3:43]|         return False
[F3:44]| 
[F3:45]|     def update_prompt(self):
[F3:46]|         cwd_name = os.path.basename(os.getcwd())
[F3:47]|         env_str = f"({self.conda_env}) " if self.conda_env else ""
[F3:48]|         is_running = self._is_active(self.current_queue)
[F3:49]|         status_part = f"\033[92m(tq:{self.current_queue}|ON)\033[0m" if is_running else f"\033[91m(tq:{self.current_queue}|OFF)\033[0m"
[F3:50]|         self.prompt = f'\033[93m{env_str}\033[0m\033[96m{cwd_name} {status_part} > '
[F3:51]| 
[F3:52]|     def postcmd(self, stop, line):
[F3:53]|         self.update_prompt()
[F3:54]|         return stop
[F3:55]| 
[F3:56]|     # --- Commands ---
[F3:57]|     def do_cd(self, arg):
[F3:58]|         try: os.chdir(os.path.expanduser(arg) if arg else os.path.expanduser("~"))
[F3:59]|         except Exception as e: print(f"[!] Error: {e}")
[F3:60]| 
[F3:61]|     def do_ls(self, arg): os.system("ls --color=auto " + arg)
[F3:62]|     def do_ll(self, arg): os.system("ls -l --color=auto " + arg)
[F3:63]| 
[F3:64]|     def do_env(self, arg):
[F3:65]|         """
[F3:66]|         Manage Conda environments.
[F3:67]|         Usage: 
[F3:68]|           env list              : List all available environments
[F3:69]|           env activate <name>   : Switch session environment
[F3:70]|           env <name>            : Shorthand for activate
[F3:71]|         """
[F3:72]|         args = arg.split()
[F3:73]|         
[F3:74]|         # 1. 无参数：显示当前
[F3:75]|         if not args:
[F3:76]|             print(f"[*] Current session env: {self.conda_env}")
[F3:77]|             return
[F3:78]|         
[F3:79]|         command = args[0]
[F3:80]|         
[F3:81]|         # 2. env list
[F3:82]|         if command == "list":
[F3:83]|             print("[*] invoking 'conda env list'...")
[F3:84]|             os.system("conda env list")
[F3:85]|             return
[F3:86]|             
[F3:87]|         # 3. env activate <name>
[F3:88]|         if command == "activate":
[F3:89]|             if len(args) < 2:
[F3:90]|                 print("[!] Usage: env activate <env_name>")
[F3:91]|                 return
[F3:92]|             target = args[1]
[F3:93]|         else:
[F3:94]|             # 4. env <name> (快捷方式)
[F3:95]|             target = command
[F3:96]|             
[F3:97]|         # 执行切换
[F3:98]|         self.conda_env = target
[F3:99]|         self.update_prompt()
[F3:100]|         print(f"[*] Switched session env to: {self.conda_env}")
[F3:101]| 
[F3:102]|     def do_use(self, arg):
[F3:103]|         """Switch queue."""
[F3:104]|         if arg:
[F3:105]|             self.current_queue = arg.strip()
[F3:106]|             self.history_cache = [] 
[F3:107]|             print(f"[*] Switched to queue: {self.current_queue}")
[F3:108]| 
[F3:109]|     def do_st(self, arg):
[F3:110]|         """Show System Status."""
[F3:111]|         print(f"\n=== System Status ({time.strftime('%H:%M:%S')}) ===")
[F3:112]|         queues = set(os.path.basename(f).split('.')[0] for f in 
[F3:113]|                      glob.glob(os.path.join(BASE_DIR, "*.queue")) + 
[F3:114]|                      glob.glob(os.path.join(BASE_DIR, "*.running")))
[F3:115]|         queues.add(self.current_queue)
[F3:116]|         if not queues: print("[*] No queues found."); return
[F3:117]| 
[F3:118]|         for q in sorted(list(queues)):
[F3:119]|             run_file = os.path.join(BASE_DIR, f"{q}.running")
[F3:120]|             q_file = os.path.join(BASE_DIR, f"{q}.queue")
[F3:121]|             is_active = self._is_active(q)
[F3:122]|             
[F3:123]|             status_str = "\033[91m[STOPPED]\033[0m" if not is_active else "\033[92m[IDLE]\033[0m"
[F3:124]|             log_info = ""
[F3:125]| 
[F3:126]|             if is_active and os.path.exists(run_file):
[F3:127]|                 try:
[F3:128]|                     with open(run_file) as f:
[F3:129]|                         lines = f.read().splitlines()
[F3:130]|                         # 新格式: PID, Prio, Grace, Tag, Log, Cmd (6行)
[F3:131]|                         if len(lines) >= 6:
[F3:132]|                             pid, prio, _, tag, log_path, cmd = lines[0], lines[1], lines[2], lines[3], lines[4], lines[5]
[F3:133]|                             cmd_short = (cmd[:30] + '...') if len(cmd) > 30 else cmd
[F3:134]|                             log_short = os.path.basename(log_path)
[F3:135]|                             tag_display = f" [{tag}]" if tag != "default" else ""
[F3:136]|                             status_str = f"\033[94m[RUN]\033[0m PID:{pid} Prio:{prio}{tag_display} | {cmd_short}"
[F3:137]|                             log_info = f"\n         ├─ Log: \033[3m.../{log_short}\033[0m"
[F3:138]|                         elif len(lines) >= 5: # 兼容旧版 (无 Tag)
[F3:139]|                             status_str = f"\033[94m[RUN]\033[0m PID:{lines[0]} (Old Format)"
[F3:140]|                 except: pass
[F3:141]|             
[F3:142]|             count = sum(1 for _ in open(q_file)) if os.path.exists(q_file) else 0
[F3:143]|             pointer = "->" if q == self.current_queue else "  "
[F3:144]|             print(f"{pointer} {q:<6} : {status_str}{log_info}")
[F3:145]|             if count > 0: print(f"         └─ {count} tasks waiting.")
[F3:146]|         print("")
[F3:147]|     
[F3:148]|     do_status = do_st
[F3:149]| 
[F3:150]|     def do_q(self, arg):
[F3:151]|         target = arg.strip() if arg else self.current_queue
[F3:152]|         q_file = os.path.join(BASE_DIR, f"{target}.queue")
[F3:153]|         if not os.path.exists(q_file) or os.path.getsize(q_file) == 0:
[F3:154]|             print(f"[*] Queue '{target}' is empty."); return
[F3:155]|         print(f"\n=== Queue Details: {target} ===")
[F3:156]|         print(f"{'ID':<4} | {'Prio':<5} | {'Grace':<5} | {'Tag':<10} | {'Command'}")
[F3:157]|         print("-" * 75)
[F3:158]|         with open(q_file, 'r') as f:
[F3:159]|             for idx, line in enumerate(f.readlines()):
[F3:160]|                 parts = line.strip().split(':', 3)
[F3:161]|                 if len(parts) == 4:
[F3:162]|                     print(f"{idx+1:<4} | {parts[0]:<5} | {parts[1]:<5} | {parts[2]:<10} | {parts[3]}")
[F3:163]|                 elif len(parts) == 3:
[F3:164]|                     print(f"{idx+1:<4} | {parts[0]:<5} | {parts[1]:<5} | {'-':<10} | {parts[2]}")
[F3:165]|         print("")
[F3:166]| 
[F3:167]|     def do_rm(self, arg):
[F3:168]|         try:
[F3:169]|             target_idx = int(arg) - 1
[F3:170]|             q_file = os.path.join(BASE_DIR, f"{self.current_queue}.queue")
[F3:171]|             if not os.path.exists(q_file): return
[F3:172]|             with open(q_file, 'r+') as f:
[F3:173]|                 fcntl.flock(f, fcntl.LOCK_EX)
[F3:174]|                 try:
[F3:175]|                     lines = f.readlines()
[F3:176]|                     if 0 <= target_idx < len(lines):
[F3:177]|                         removed = lines.pop(target_idx).strip()
[F3:178]|                         f.seek(0); f.truncate()
[F3:179]|                         f.writelines(lines)
[F3:180]|                         print(f"[*] Removed: {removed}")
[F3:181]|                     else: print(f"[!] Invalid ID.")
[F3:182]|                 finally: fcntl.flock(f, fcntl.LOCK_UN)
[F3:183]|         except Exception as e: print(f"[!] Error: {e}")
[F3:184]| 
[F3:185]|     def do_purge(self, arg):
[F3:186]|         target = arg.strip() if arg else self.current_queue
[F3:187]|         q_file = os.path.join(BASE_DIR, f"{target}.queue")
[F3:188]|         if os.path.exists(q_file):
[F3:189]|             if input(f"[?] Delete all in '{target}'? (y/N) ").lower() == 'y':
[F3:190]|                 os.remove(q_file); print("[*] Cleared.")
[F3:191]| 
[F3:192]|     def do_hist(self, arg):
[F3:193]|         target = arg.strip() if arg else self.current_queue
[F3:194]|         pattern = os.path.join(TASK_LOG_DIR, f"{target}_*.log")
[F3:195]|         files = glob.glob(pattern)
[F3:196]|         files.sort(key=os.path.getmtime, reverse=True)
[F3:197]|         self.history_cache = files 
[F3:198]|         if not files: print(f"[*] No history for '{target}'."); return
[F3:199]| 
[F3:200]|         print(f"\n=== Task History: {target} (Showing last 10) ===")
[F3:201]|         print(f"{'ID':<4} | {'Time':<19} | {'Size':<10} | {'File'}")
[F3:202]|         print("-" * 65)
[F3:203]|         for idx, fpath in enumerate(files[:10]):
[F3:204]|             fname = os.path.basename(fpath)
[F3:205]|             dt_str = datetime.datetime.fromtimestamp(os.path.getmtime(fpath)).strftime('%Y-%m-%d %H:%M:%S')
[F3:206]|             size_kb = os.path.getsize(fpath) / 1024
[F3:207]|             print(f"{idx+1:<4} | {dt_str:<19} | {size_kb:.1f} KB    | {fname}")
[F3:208]|         print(f"\n(Tip: 'view <id>')\n")
[F3:209]| 
[F3:210]|     def do_view(self, arg):
[F3:211]|         if not arg: print("[!] Usage: view <id>"); return
[F3:212]|         try:
[F3:213]|             idx = int(arg) - 1
[F3:214]|             if not self.history_cache: print("[!] Run 'hist' first."); return
[F3:215]|             if 0 <= idx < len(self.history_cache): os.system(f"less -R {self.history_cache[idx]}")
[F3:216]|             else: print(f"[!] Invalid ID.")
[F3:217]|         except: print("[!] Invalid ID.")
[F3:218]| 
[F3:219]|     def do_start(self, arg):
[F3:220]|         target = arg.strip() if arg else self.current_queue
[F3:221]|         if self._is_active(target): print(f"[!] '{target}' running."); return
[F3:222]|         lock = f"/tmp/scheduler_{target}.lock"
[F3:223]|         if os.path.exists(lock): os.remove(lock)
[F3:224]|         print(f"[*] Launching scheduler for '{target}'...")
[F3:225]|         os.system(f"nohup bash {SCHEDULER_SCRIPT} {target} > {LOG_DIR}/scheduler_{target}.log 2>&1 &")
[F3:226]|         for _ in range(20):
[F3:227]|             if self._is_active(target): break
[F3:228]|             time.sleep(0.1)
[F3:229]| 
[F3:230]|     def do_stop(self, arg):
[F3:231]|         target = arg.strip() if arg else self.current_queue
[F3:232]|         if self._is_active(target):
[F3:233]|             try:
[F3:234]|                 with open(f"/tmp/scheduler_{target}.lock") as f: os.system(f"kill {f.read().strip()}")
[F3:235]|             except: pass
[F3:236]|             for _ in range(30):
[F3:237]|                 if not self._is_active(target): print(f"[*] Stopped."); break
[F3:238]|                 time.sleep(0.1)
[F3:239]|         else: print("[!] Not running.")
[F3:240]| 
[F3:241]|     def do_kill(self, arg):
[F3:242]|         target = arg.strip() if arg else self.current_queue
[F3:243]|         run_file = os.path.join(BASE_DIR, f"{target}.running")
[F3:244]|         if os.path.exists(run_file):
[F3:245]|             try:
[F3:246]|                 with open(run_file) as f: pid = f.readline().strip()
[F3:247]|                 print(f"[*] Sending SIGTERM to Group -{pid}...")
[F3:248]|                 os.killpg(int(pid), 15)
[F3:249]|             except: pass
[F3:250]|         else: print("[!] No running task.")
[F3:251]| 
[F3:252]|     def do_cat(self, arg):
[F3:253]|         target = arg.strip() if arg else self.current_queue
[F3:254]|         run_file = os.path.join(BASE_DIR, f"{target}.running")
[F3:255]|         if os.path.exists(run_file):
[F3:256]|             with open(run_file) as f:
[F3:257]|                 lines = f.read().splitlines()
[F3:258]|                 # 兼容不同版本，LogPath 通常在倒数第二行或固定行，这里用新版的 Line 5 (index 4)
[F3:259]|                 if len(lines) >= 6: os.system(f"tail -n 20 {lines[4]}")
[F3:260]|                 elif len(lines) >= 5: os.system(f"tail -n 20 {lines[3]}")
[F3:261]|     
[F3:262]|     def do_tail(self, arg):
[F3:263]|         target = arg.strip() if arg else self.current_queue
[F3:264]|         os.system(f"tail -f {LOG_DIR}/scheduler_{target}.log")
[F3:265]| 
[F3:266]|     def do_man(self, arg):
[F3:267]|         print("""
[F3:268]| \033[1mTask Queue (tq) v5.9 Manual\033[0m
[F3:269]| ===========================================
[F3:270]| \033[93mNavigation & System:\033[0m
[F3:271]|   st (status)   : Show summary of ALL queues
[F3:272]|   ls / ll / cd  : File system navigation
[F3:273]| 
[F3:274]| \033[93mEnvironment Management (Conda-like):\033[0m
[F3:275]|   env list             : List all Conda environments
[F3:276]|   env activate <name>  : Switch session environment
[F3:277]|   env <name>           : Shortcut to switch environment
[F3:278]| 
[F3:279]| \033[93mQueue Management:\033[0m
[F3:280]|   <command>     : Submit task (e.g., 'python train.py -p 10')
[F3:281]|   q             : List detailed tasks in current queue
[F3:282]|   rm <id>       : Remove task by ID
[F3:283]|   purge         : Remove ALL waiting tasks
[F3:284]| 
[F3:285]| \033[93mLogs & History:\033[0m
[F3:286]|   hist          : List execution logs
[F3:287]|   view <id>     : Open log with 'less'
[F3:288]|   cat           : Show tail of CURRENTLY RUNNING task log
[F3:289]|   tail          : Show SCHEDULER system log
[F3:290]| 
[F3:291]| \033[93mScheduler Control:\033[0m
[F3:292]|   start / stop  : Start/Stop scheduler
[F3:293]|   kill          : Immediately kill current running task
[F3:294]| 
[F3:295]| \033[93mSubmission Options:\033[0m
[F3:296]|   -p <int>      : Priority (default 100)
[F3:297]|   -g <int>      : Grace period (sec, default 180)
[F3:298]|   -t <str>      : Tag for log (default 'default')
[F3:299]|   -e <str>      : Conda Env (overrides session default)
[F3:300]| """)
[F3:301]| 
[F3:302]|     def default(self, line):
[F3:303]|         raw = line.strip()
[F3:304]|         if not raw: return
[F3:305]|         if raw == "EOF": return True
[F3:306]|         if len(raw) < 2: return 
[F3:307]| 
[F3:308]|         prio, grace, tag = 100, 180, "default"
[F3:309]|         # 默认使用当前 session 的环境
[F3:310]|         target_env = self.conda_env 
[F3:311]|         
[F3:312]|         # 1. 解析 Priority
[F3:313]|         p_match = re.search(r'\s+(-p|--priority)\s+(\d+)', raw)
[F3:314]|         if p_match: prio = int(p_match.group(2)); raw = raw.replace(p_match.group(0), "")
[F3:315]|         
[F3:316]|         # 2. 解析 Grace
[F3:317]|         g_match = re.search(r'\s+(-g|--grace)\s+(\d+)', raw)
[F3:318]|         if g_match: grace = int(g_match.group(2)); raw = raw.replace(g_match.group(0), "")
[F3:319]|         
[F3:320]|         # 3. 解析 Tag
[F3:321]|         t_match = re.search(r'\s+(-t|--tag)\s+(\S+)', raw)
[F3:322]|         if t_match: tag = t_match.group(2); raw = raw.replace(t_match.group(0), "")
[F3:323]| 
[F3:324]|         # 4. 解析 Env (新增!)
[F3:325]|         e_match = re.search(r'\s+(-e|--env)\s+(\S+)', raw)
[F3:326]|         if e_match: 
[F3:327]|             target_env = e_match.group(2)
[F3:328]|             raw = raw.replace(e_match.group(0), "")
[F3:329]|         
[F3:330]|         cmd_content = raw.strip()
[F3:331]|         final_cmd = cmd_content
[F3:332]|         
[F3:333]|         # 使用 target_env 进行封装，而不是 self.conda_env
[F3:334]|         if target_env and target_env != "base":
[F3:335]|             try:
[F3:336]|                 conda_base = os.popen("conda info --base 2>/dev/null").read().strip()
[F3:337]|                 if conda_base:
[F3:338]|                     conda_sh = os.path.join(conda_base, "etc/profile.d/conda.sh")
[F3:339]|                     if os.path.exists(conda_sh):
[F3:340]|                         final_cmd = f"source {conda_sh} && conda activate {target_env} && {cmd_content}"
[F3:341]|             except: pass
[F3:342]| 
[F3:343]|         q_file = os.path.join(BASE_DIR, f"{self.current_queue}.queue")
[F3:344]|         
[F3:345]|         try:
[F3:346]|             with open(q_file, 'a') as f:
[F3:347]|                 fcntl.flock(f, fcntl.LOCK_EX)
[F3:348]|                 try:
[F3:349]|                     f.write(f"{prio}:{grace}:{tag}:{final_cmd}\n")
[F3:350]|                 finally: fcntl.flock(f, fcntl.LOCK_UN)
[F3:351]|             
[F3:352]|             # 提示信息中增加 Env 显示
[F3:353]|             print(f"[+] Submitted to '{self.current_queue}' (Env: {target_env}, Tag: {tag})")
[F3:354]|         except Exception as e: print(f"[!] Submission failed: {e}")
[F3:355]| 
[F3:356]|     def _complete_path(self, text, line, begidx, endidx):
[F3:357]|         if not text: completions = glob.glob('*')
[F3:358]|         else: completions = glob.glob(os.path.expanduser(text) + '*')
[F3:359]|         return [c + "/" if os.path.isdir(c) else c for c in completions]
[F3:360]|     
[F3:361]|     def _get_conda_envs(self):
[F3:362]|         """Helper to find available conda environments for tab completion."""
[F3:363]|         envs = []
[F3:364]|         try:
[F3:365]|             # 1. 尝试从 conda info 获取 (最准确但慢)
[F3:366]|             # 为了速度，我们这里简单扫描 envs 目录
[F3:367]|             conda_base = os.popen("conda info --base 2>/dev/null").read().strip()
[F3:368]|             if conda_base and os.path.exists(conda_base):
[F3:369]|                 envs_dir = os.path.join(conda_base, "envs")
[F3:370]|                 if os.path.exists(envs_dir):
[F3:371]|                     envs = [d for d in os.listdir(envs_dir) if os.path.isdir(os.path.join(envs_dir, d))]
[F3:372]|                 # base
[F3:373]|                 envs.append("base")
[F3:374]|         except: pass
[F3:375]|         return envs
[F3:376]|     
[F3:377]|     def complete_env(self, text, line, begidx, endidx):
[F3:378]|         """Tab completion for 'env' command."""
[F3:379]|         # 补全子命令
[F3:380]|         subcommands = ["list", "activate"]
[F3:381]|         args = line.split()
[F3:382]|         
[F3:383]|         # 如果是输入第一个参数 (env l...)
[F3:384]|         if len(args) == 1 or (len(args) == 2 and not line.endswith(' ')):
[F3:385]|             # 混合补全：既补全子命令，也补全环境名（方便快捷方式）
[F3:386]|             candidates = subcommands + self._get_conda_envs()
[F3:387]|             return [s for s in candidates if s.startswith(text)]
[F3:388]|             
[F3:389]|         # 如果是输入第二个参数 (env activate m...)
[F3:390]|         if len(args) >= 2 and args[1] == "activate":
[F3:391]|             envs = self._get_conda_envs()
[F3:392]|             return [e for e in envs if e.startswith(text)]
[F3:393]|             
[F3:394]|         return []
[F3:395]| 
[F3:396]|     def complete_cd(self, text, line, begidx, endidx): return self._complete_path(text, line, begidx, endidx)
[F3:397]|     def complete_ls(self, text, line, begidx, endidx): return self._complete_path(text, line, begidx, endidx)
[F3:398]|     def complete_ll(self, text, line, begidx, endidx): return self._complete_path(text, line, begidx, endidx)
[F3:399]|     def completedefault(self, text, line, begidx, endidx): return self._complete_path(text, line, begidx, endidx)
[F3:400]| 
[F3:401]| if __name__ == '__main__':
[F3:402]|     try: TaskQueueShell().cmdloop()
[F3:403]|     except KeyboardInterrupt: print("\nBye.")

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
文件路径: uninstall.sh(F4) (约合大小: 2 KB)
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
[F4:1]| #!/bin/bash
[F4:2]| # =========================================================
[F4:3]| # Task Queue System Uninstall Script
[F4:4]| # =========================================================
[F4:5]| 
[F4:6]| # --- 颜色定义 ---
[F4:7]| GREEN='\033[0;32m'
[F4:8]| RED='\033[0;31m'
[F4:9]| YELLOW='\033[1;33m'
[F4:10]| NC='\033[0m'
[F4:11]| 
[F4:12]| CURRENT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
[F4:13]| RC_FILE="$HOME/.bashrc"
[F4:14]| 
[F4:15]| # 检测 zsh (保持与 setup.sh 一致的逻辑)
[F4:16]| if [ -n "$ZSH_VERSION" ]; then
[F4:17]|     RC_FILE="$HOME/.zshrc"
[F4:18]| elif [ -f "$HOME/.zshrc" ] && [ "$SHELL" == "/bin/zsh" ]; then
[F4:19]|     RC_FILE="$HOME/.zshrc"
[F4:20]| fi
[F4:21]| 
[F4:22]| echo -e "${RED}[!] Task Queue System Uninstaller${NC}"
[F4:23]| echo -e "    Target Config: $RC_FILE"
[F4:24]| echo -e "    Target Dir:    $CURRENT_DIR"
[F4:25]| 
[F4:26]| # --- 1. 确认提示 ---
[F4:27]| read -p "Are you sure you want to uninstall? This will remove logs and config. (y/N) " -n 1 -r
[F4:28]| echo
[F4:29]| if [[ ! $REPLY =~ ^[Yy]$ ]]; then
[F4:30]|     echo "Aborted."
[F4:31]|     exit 1
[F4:32]| fi
[F4:33]| 
[F4:34]| # --- 2. 清理 Shell 配置 ---
[F4:35]| echo -e "\n${YELLOW}[1/2] Removing configuration from $RC_FILE...${NC}"
[F4:36]| 
[F4:37]| if grep -q "Task Queue System" "$RC_FILE"; then
[F4:38]|     # 1. 创建备份
[F4:39]|     cp "$RC_FILE" "${RC_FILE}.bak_tq"
[F4:40]|     echo "    Backup created at ${RC_FILE}.bak_tq"
[F4:41]| 
[F4:42]|     # 2. 使用 sed 删除两个标记之间的内容 (包括标记本身)
[F4:43]|     # 标记是: # --- Task Queue System --- 到 # ---------------------------
[F4:44]|     # 使用临时文件方式以兼容 Linux(GNU) 和 macOS(BSD) 的 sed 差异
[F4:45]|     
[F4:46]|     sed '/# --- Task Queue System ---/,/# ---------------------------/d' "$RC_FILE" > "${RC_FILE}.tmp" && mv "${RC_FILE}.tmp" "$RC_FILE"
[F4:47]|     
[F4:48]|     echo -e "    ${GREEN}Configuration block removed.${NC}"
[F4:49]| else
[F4:50]|     echo "    No Task Queue configuration found in $RC_FILE."
[F4:51]| fi
[F4:52]| 
[F4:53]| # --- 3. 清理运行时文件 ---
[F4:54]| echo -e "\n${YELLOW}[2/2] Cleaning up runtime files...${NC}"
[F4:55]| 
[F4:56]| # 删除日志目录
[F4:57]| if [ -d "$CURRENT_DIR/logs" ]; then
[F4:58]|     rm -rf "$CURRENT_DIR/logs"
[F4:59]|     echo "    Removed logs/ directory."
[F4:60]| fi
[F4:61]| 
[F4:62]| # 删除队列状态文件
[F4:63]| rm -f "$CURRENT_DIR"/*.queue
[F4:64]| rm -f "$CURRENT_DIR"/*.running
[F4:65]| rm -f "$CURRENT_DIR"/*.tmp
[F4:66]| rm -f /tmp/scheduler_*.lock  # 清理系统临时目录的锁
[F4:67]| 
[F4:68]| echo "    Removed *.queue, *.running, and lock files."
[F4:69]| 
[F4:70]| # --- 结束 ---
[F4:71]| echo -e "\n${GREEN}=======================================${NC}"
[F4:72]| echo -e "${GREEN}      Uninstallation Complete          ${NC}"
[F4:73]| echo -e "${GREEN}=======================================${NC}"
[F4:74]| echo -e "1. Please run: ${YELLOW}source $RC_FILE${NC} to update your shell."
[F4:75]| echo -e "2. You can now safely remove this directory:"
[F4:76]| echo -e "   rm -rf $CURRENT_DIR"
[F4:77]| echo ""

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
文件路径: setup.sh(F5) (约合大小: 2 KB)
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
[F5:1]| #!/bin/bash
[F5:2]| # =========================================================
[F5:3]| # Task Queue System Setup Script (Lite Version)
[F5:4]| # =========================================================
[F5:5]| 
[F5:6]| set -e
[F5:7]| 
[F5:8]| # --- 颜色定义 ---
[F5:9]| GREEN='\033[0;32m'
[F5:10]| RED='\033[0;31m'
[F5:11]| YELLOW='\033[1;33m'
[F5:12]| NC='\033[0m'
[F5:13]| 
[F5:14]| # --- 路径定义 ---
[F5:15]| CURRENT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
[F5:16]| RC_FILE="$HOME/.bashrc"
[F5:17]| 
[F5:18]| # 检测是否使用 zsh
[F5:19]| if [ -n "$ZSH_VERSION" ]; then
[F5:20]|     RC_FILE="$HOME/.zshrc"
[F5:21]| elif [ -f "$HOME/.zshrc" ] && [ "$SHELL" == "/bin/zsh" ]; then
[F5:22]|     RC_FILE="$HOME/.zshrc"
[F5:23]| fi
[F5:24]| 
[F5:25]| echo -e "${GREEN}[*] Setting up Task Queue System...${NC}"
[F5:26]| echo -e "    Root: $CURRENT_DIR"
[F5:27]| 
[F5:28]| # --- 1. 环境检查 (Fail Fast) ---
[F5:29]| echo -e "\n${YELLOW}[1/3] Checking Prerequisites...${NC}"
[F5:30]| 
[F5:31]| # 检查 python3 命令是否存在
[F5:32]| if ! command -v python3 &> /dev/null; then
[F5:33]|     echo -e "${RED}[ERROR] Python 3 is not installed or not in PATH.${NC}"
[F5:34]|     echo -e "Please install Python 3.6+ first (e.g., 'sudo apt install python3' or install Miniconda)."
[F5:35]|     exit 1
[F5:36]| fi
[F5:37]| 
[F5:38]| # 检查 Python 版本 (需要 >= 3.6 支持 f-string)
[F5:39]| python3 -c "import sys; sys.exit(0 if sys.version_info >= (3,6) else 1)" 2>/dev/null
[F5:40]| if [ $? -ne 0 ]; then
[F5:41]|     echo -e "${RED}[ERROR] Python version too old.$(python3 --version)${NC}"
[F5:42]|     echo -e "Task Queue requires Python 3.6 or higher."
[F5:43]|     exit 1
[F5:44]| fi
[F5:45]| 
[F5:46]| echo -e "    Found: $(python3 --version) at $(which python3)"
[F5:47]| 
[F5:48]| # --- 2. 目录与权限 ---
[F5:49]| echo -e "\n${YELLOW}[2/3] Initializing Directories & Permissions...${NC}"
[F5:50]| 
[F5:51]| chmod +x "$CURRENT_DIR/scheduler.sh"
[F5:52]| chmod +x "$CURRENT_DIR/tq.py"
[F5:53]| echo "    +x scheduler.sh & tq.py"
[F5:54]| 
[F5:55]| mkdir -p "$CURRENT_DIR/logs/tasks"
[F5:56]| echo "    Created logs/tasks/"
[F5:57]| 
[F5:58]| # --- 3. 配置 Shell ---
[F5:59]| echo -e "\n${YELLOW}[3/3] Configuring Shell ($RC_FILE)...${NC}"
[F5:60]| 
[F5:61]| # 构造配置块
[F5:62]| TQ_CONFIG="# --- Task Queue System ---
[F5:63]| export TQ_HOME=\"$CURRENT_DIR\"
[F5:64]| alias tq=\"python3 \$TQ_HOME/tq.py\"
[F5:65]| # ---------------------------"
[F5:66]| 
[F5:67]| # 检查是否已存在
[F5:68]| if grep -q "Task Queue System" "$RC_FILE"; then
[F5:69]|     echo -e "${YELLOW}    [WARN] Configuration already exists in $RC_FILE. Skipping.${NC}"
[F5:70]|     echo -e "    Please check $RC_FILE manually if paths have changed."
[F5:71]| else
[F5:72]|     echo -e "$TQ_CONFIG" >> "$RC_FILE"
[F5:73]|     echo "    Added 'tq' alias and variables to $RC_FILE."
[F5:74]| fi
[F5:75]| 
[F5:76]| # --- 完成 ---
[F5:77]| echo -e "\n${GREEN}=======================================${NC}"
[F5:78]| echo -e "${GREEN}      Setup Completed Successfully!    ${NC}"
[F5:79]| echo -e "${GREEN}=======================================${NC}"
[F5:80]| echo -e "To activate changes, please run:"
[F5:81]| echo -e "\n    ${YELLOW}source $RC_FILE${NC}\n"
[F5:82]| echo -e "Then try: tq ls"

################################################################################
文件路径: examples/demo_task.py(F6) (约合大小: 0 KB)
################################################################################
[F6:1]| import time
[F6:2]| import signal
[F6:3]| import sys
[F6:4]| import os
[F6:5]| 
[F6:6]| stop_requested = False
[F6:7]| 
[F6:8]| def signal_handler(signum, frame):
[F6:9]|     global stop_requested
[F6:10]|     print(f"\n[Task] Received signal {signum}. Stopping gracefully...", flush=True)
[F6:11]|     stop_requested = True
[F6:12]| 
[F6:13]| # 注册 SIGTERM (调度器发出的信号)
[F6:14]| signal.signal(signal.SIGTERM, signal_handler)
[F6:15]| 
[F6:16]| print(f"[Task] Started with PID: {os.getpid()}", flush=True)
[F6:17]| total_epochs = 100
[F6:18]| 
[F6:19]| for epoch in range(total_epochs):
[F6:20]|     if stop_requested:
[F6:21]|         print(f"[Task] Saving checkpoint at epoch {epoch}...", flush=True)
[F6:22]|         time.sleep(2) # 模拟保存耗时
[F6:23]|         print("[Task] Save complete. Exiting.", flush=True)
[F6:24]|         sys.exit(0)
[F6:25]|     
[F6:26]|     print(f"[Task] Training epoch {epoch}/{total_epochs}...", flush=True)
[F6:27]|     time.sleep(2) # 模拟训练耗时

################################################################################
文件路径: tests/test_core.py(F7) (约合大小: 2 KB)
################################################################################
[F7:1]| import os
[F7:2]| import pytest
[F7:3]| import shutil
[F7:4]| from unittest.mock import MagicMock, patch
[F7:5]| 
[F7:6]| # 为了方便测试，我们简单模拟 tq.py 的核心逻辑，或者你可以修改 tq.py 为模块导入
[F7:7]| # 这里我们采用“白盒测试”逻辑，复制关键路径进行验证
[F7:8]| 
[F7:9]| def submit_task_logic(base_dir, queue_name, current_env, raw_input):
[F7:10]|     """
[F7:11]|     这是从 tq.py 提取出的纯逻辑函数，用于测试
[F7:12]|     """
[F7:13]|     import re
[F7:14]|     priority = 100
[F7:15]|     grace = 180
[F7:16]|     
[F7:17]|     # 解析逻辑
[F7:18]|     p_match = re.search(r'\s+(-p|--priority)\s+(\d+)', raw_input)
[F7:19]|     if p_match:
[F7:20]|         priority = int(p_match.group(2))
[F7:21]|         raw_input = raw_input.replace(p_match.group(0), "")
[F7:22]|         
[F7:23]|     g_match = re.search(r'\s+(-g|--grace)\s+(\d+)', raw_input)
[F7:24]|     if g_match:
[F7:25]|         grace = int(g_match.group(2))
[F7:26]|         raw_input = raw_input.replace(g_match.group(0), "")
[F7:27]| 
[F7:28]|     cmd_content = raw_input.strip()
[F7:29]|     final_cmd = cmd_content
[F7:30]| 
[F7:31]|     # Conda 逻辑
[F7:32]|     if current_env and current_env != "base":
[F7:33]|         final_cmd = f"source /mock/conda.sh && conda activate {current_env} && {cmd_content}"
[F7:34]| 
[F7:35]|     q_file = os.path.join(base_dir, f"{queue_name}.queue")
[F7:36]|     with open(q_file, 'a') as f:
[F7:37]|         f.write(f"{priority}:{grace}:{final_cmd}\n")
[F7:38]|     
[F7:39]|     return priority, grace, final_cmd
[F7:40]| 
[F7:41]| @pytest.fixture
[F7:42]| def workspace(tmp_path):
[F7:43]|     """创建临时工作目录"""
[F7:44]|     d = tmp_path / "task_queue"
[F7:45]|     d.mkdir()
[F7:46]|     return str(d)
[F7:47]| 
[F7:48]| def test_basic_submission(workspace):
[F7:49]|     """测试：普通提交"""
[F7:50]|     p, g, cmd = submit_task_logic(workspace, "0", "base", "python train.py")
[F7:51]|     
[F7:52]|     assert p == 100
[F7:53]|     assert g == 180
[F7:54]|     assert cmd == "python train.py"
[F7:55]|     
[F7:56]|     with open(os.path.join(workspace, "0.queue")) as f:
[F7:57]|         line = f.read().strip()
[F7:58]|     assert line == "100:180:python train.py"
[F7:59]| 
[F7:60]| def test_priority_and_grace(workspace):
[F7:61]|     """测试：参数解析"""
[F7:62]|     p, g, cmd = submit_task_logic(workspace, "0", "base", "python train.py -p 10 --grace 600")
[F7:63]|     
[F7:64]|     assert p == 10
[F7:65]|     assert g == 600
[F7:66]|     assert cmd == "python train.py" # 参数应该被移除
[F7:67]| 
[F7:68]| def test_conda_wrapper(workspace):
[F7:69]|     """测试：Conda 环境包裹"""
[F7:70]|     p, g, cmd = submit_task_logic(workspace, "0", "my_env", "torchrun main.py")
[F7:71]|     
[F7:72]|     # 验证命令是否被包裹
[F7:73]|     assert "conda activate my_env" in cmd
[F7:74]|     assert "torchrun main.py" in cmd
[F7:75]| 
[F7:76]| def test_multi_gpu_queue(workspace):
[F7:77]|     """测试：多GPU队列文件生成"""
[F7:78]|     submit_task_logic(workspace, "0,1", "base", "sleep 10")
[F7:79]|     assert os.path.exists(os.path.join(workspace, "0,1.queue"))
[F7:80]| 
[F7:81]| def test_scheduler_read_write(workspace):
[F7:82]|     """测试：模拟调度器读写 Running 文件"""
[F7:83]|     # 模拟 Running 文件内容 (PID, Prio, Grace, Cmd)
[F7:84]|     run_file = os.path.join(workspace, "0.running")
[F7:85]|     with open(run_file, 'w') as f:
[F7:86]|         f.write("12345\n50\n600\npython long_task.py")
[F7:87]|         
[F7:88]|     with open(run_file) as f:
[F7:89]|         lines = f.read().splitlines()
[F7:90]|     
[F7:91]|     assert lines[0] == "12345"
[F7:92]|     assert lines[1] == "50"
[F7:93]|     assert lines[2] == "600"

################################################################################
文件路径: tests/test_env_features.py(F8) (约合大小: 6 KB)
################################################################################
[F8:1]| import sys
[F8:2]| import os
[F8:3]| import pytest
[F8:4]| from unittest.mock import MagicMock, patch
[F8:5]| 
[F8:6]| # --- 1. 导入 tq 模块 ---
[F8:7]| current_dir = os.path.dirname(os.path.abspath(__file__))
[F8:8]| parent_dir = os.path.dirname(current_dir)
[F8:9]| if parent_dir not in sys.path:
[F8:10]|     sys.path.insert(0, parent_dir)
[F8:11]| 
[F8:12]| import tq
[F8:13]| 
[F8:14]| # --- 2. 测试环境 Fixture ---
[F8:15]| @pytest.fixture
[F8:16]| def mock_workspace(tmp_path):
[F8:17]|     """
[F8:18]|     创建一个隔离的测试环境，并 Patch 掉 tq.py 中的全局路径变量
[F8:19]|     """
[F8:20]|     d = tmp_path / "task_queue"
[F8:21]|     d.mkdir()
[F8:22]|     logs = d / "logs"
[F8:23]|     logs.mkdir()
[F8:24]|     tasks = logs / "tasks"
[F8:25]|     tasks.mkdir()
[F8:26]|     
[F8:27]|     # Patch 全局变量，防止测试写入真实的 ~/task_queue
[F8:28]|     with patch("tq.BASE_DIR", str(d)), \
[F8:29]|          patch("tq.LOG_DIR", str(logs)), \
[F8:30]|          patch("tq.TASK_LOG_DIR", str(tasks)):
[F8:31]|         yield d
[F8:32]| 
[F8:33]| # --- 3. 辅助函数：Mock Conda ---
[F8:34]| @pytest.fixture
[F8:35]| def mock_conda_system():
[F8:36]|     """
[F8:37]|     Mock 掉 os.popen 和 os.path.exists，让 tq 以为系统里有 Conda。
[F8:38]|     """
[F8:39]|     # [关键修复]：在 Patch 之前捕获真实的 os.path.exists
[F8:40]|     real_exists = os.path.exists
[F8:41]|     
[F8:42]|     with patch("os.popen") as mock_popen, \
[F8:43]|          patch("os.path.exists") as mock_exists:
[F8:44]|         
[F8:45]|         # 1. 模拟 conda info --base 返回路径
[F8:46]|         mock_popen.return_value.read.return_value = "/mock/anaconda3"
[F8:47]|         
[F8:48]|         # 2. 模拟 conda.sh 存在
[F8:49]|         def side_effect(path):
[F8:50]|             # 如果检查的是 conda.sh，返回 True (模拟存在)
[F8:51]|             if str(path).endswith("conda.sh"):
[F8:52]|                 return True
[F8:53]|             # 对于其他路径（如 logs 目录、queue文件等），使用真实的检查逻辑
[F8:54]|             return real_exists(path)
[F8:55]|         
[F8:56]|         mock_exists.side_effect = side_effect
[F8:57]|         yield
[F8:58]| 
[F8:59]| # --- 测试用例 ---
[F8:60]| 
[F8:61]| def test_session_env_switching(mock_workspace, mock_conda_system):
[F8:62]|     """
[F8:63]|     测试功能：do_env (切换会话默认环境)
[F8:64]|     """
[F8:65]|     shell = tq.TaskQueueShell()
[F8:66]|     
[F8:67]|     # 1. 切换会话环境
[F8:68]|     shell.do_env("session_env_v1")
[F8:69]|     assert shell.conda_env == "session_env_v1"
[F8:70]|     
[F8:71]|     # 2. 提交任务
[F8:72]|     shell.default("python train.py")
[F8:73]|     
[F8:74]|     # 3. 验证队列文件
[F8:75]|     q_file = mock_workspace / "0.queue"
[F8:76]|     assert q_file.exists()
[F8:77]|     
[F8:78]|     with open(q_file, 'r') as f:
[F8:79]|         line = f.readline().strip()
[F8:80]|         
[F8:81]|     # 验证是否包含了 Conda 激活命令
[F8:82]|     # v5.7 格式: Prio:Grace:Tag:Cmd
[F8:83]|     parts = line.split(':', 3)
[F8:84]|     cmd = parts[3]
[F8:85]|     
[F8:86]|     assert "source /mock/anaconda3/etc/profile.d/conda.sh" in cmd
[F8:87]|     assert "conda activate session_env_v1" in cmd
[F8:88]|     assert "python train.py" in cmd
[F8:89]| 
[F8:90]| def test_inline_env_override(mock_workspace, mock_conda_system):
[F8:91]|     """
[F8:92]|     测试功能：-e 参数 (单行覆盖)
[F8:93]|     """
[F8:94]|     shell = tq.TaskQueueShell()
[F8:95]|     
[F8:96]|     # 保持会话环境为默认 (base)
[F8:97]|     shell.conda_env = "base"
[F8:98]|     
[F8:99]|     # 使用 -e 提交
[F8:100]|     shell.default("python data_prep.py -e data_env")
[F8:101]|     
[F8:102]|     q_file = mock_workspace / "0.queue"
[F8:103]|     with open(q_file, 'r') as f:
[F8:104]|         line = f.readline().strip()
[F8:105]|     
[F8:106]|     cmd = line.split(':', 3)[3]
[F8:107]|     
[F8:108]|     # 验证 -e 生效
[F8:109]|     assert "conda activate data_env" in cmd
[F8:110]|     # 验证没有把 -e 参数残留给 python 脚本
[F8:111]|     assert "-e data_env" not in cmd.split("&&")[-1] 
[F8:112]| 
[F8:113]| def test_priority_logic_mixed(mock_workspace, mock_conda_system):
[F8:114]|     """
[F8:115]|     测试功能：优先级逻辑 (Inline -e > Session env > Base)
[F8:116]|     模拟批量提交场景
[F8:117]|     """
[F8:118]|     shell = tq.TaskQueueShell()
[F8:119]|     q_file = mock_workspace / "0.queue"
[F8:120]|     
[F8:121]|     # 1. 设置会话环境为 global_env
[F8:122]|     shell.do_env("global_env")
[F8:123]|     
[F8:124]|     # 2. 提交三个任务
[F8:125]|     # Task A: 使用会话环境
[F8:126]|     shell.default("python task_a.py")
[F8:127]|     
[F8:128]|     # Task B: 使用 -e 覆盖
[F8:129]|     shell.default("python task_b.py --flag 1 -e local_env")
[F8:130]|     
[F8:131]|     # Task C: 使用 -e 指定 base (即不封装)
[F8:132]|     # 注意：tq.py 逻辑是 if target != "base" 才封装
[F8:133]|     shell.default("python task_c.py -e base")
[F8:134]|     
[F8:135]|     # 3. 验证
[F8:136]|     with open(q_file, 'r') as f:
[F8:137]|         lines = f.readlines()
[F8:138]|         
[F8:139]|     cmd_a = lines[0].split(':', 3)[3]
[F8:140]|     cmd_b = lines[1].split(':', 3)[3]
[F8:141]|     cmd_c = lines[2].split(':', 3)[3]
[F8:142]|     
[F8:143]|     # Task A -> global_env
[F8:144]|     assert "conda activate global_env" in cmd_a
[F8:145]|     
[F8:146]|     # Task B -> local_env (覆盖了 global)
[F8:147]|     assert "conda activate local_env" in cmd_b
[F8:148]|     assert "global_env" not in cmd_b
[F8:149]|     
[F8:150]|     # Task C -> 原生命令 (无 conda 封装)
[F8:151]|     assert "source" not in cmd_c
[F8:152]|     assert "conda activate" not in cmd_c
[F8:153]|     assert cmd_c.strip() == "python task_c.py"
[F8:154]| 
[F8:155]| def test_batch_submission_simulation(mock_workspace, mock_conda_system):
[F8:156]|     """
[F8:157]|     测试功能：模拟粘贴多行命令时的处理
[F8:158]|     """
[F8:159]|     shell = tq.TaskQueueShell()
[F8:160]|     shell.do_env("default_env")
[F8:161]|     
[F8:162]|     # 模拟一段批量文本
[F8:163]|     batch_commands = [
[F8:164]|         "python step1.py -t step1",
[F8:165]|         "python step2.py -e heavy_env -t step2 -p 50",
[F8:166]|         "python step3.py -t step3"
[F8:167]|     ]
[F8:168]|     
[F8:169]|     for cmd in batch_commands:
[F8:170]|         shell.default(cmd)
[F8:171]|         
[F8:172]|     # 读取队列
[F8:173]|     q_file = mock_workspace / "0.queue"
[F8:174]|     with open(q_file, 'r') as f:
[F8:175]|         lines = f.readlines()
[F8:176]|         
[F8:177]|     assert len(lines) == 3
[F8:178]|     
[F8:179]|     # 验证 Step 1 (继承 default_env)
[F8:180]|     assert "default_env" in lines[0]
[F8:181]|     assert "step1" in lines[0] # Tag
[F8:182]|     
[F8:183]|     # 验证 Step 2 (Override heavy_env)
[F8:184]|     assert "heavy_env" in lines[1]
[F8:185]|     assert "default_env" not in lines[1]
[F8:186]|     assert "step2" in lines[1] # Tag
[F8:187]|     assert lines[1].startswith("50:") # Priority
[F8:188]|     
[F8:189]|     # 验证 Step 3 (回到 default_env)
[F8:190]|     assert "default_env" in lines[2]
[F8:191]| 
[F8:192]| 
[F8:193]| def test_env_cli_behavior(mock_workspace, mock_conda_system):
[F8:194]|     """
[F8:195]|     测试 v5.9: env list 和 env activate 的行为
[F8:196]|     """
[F8:197]|     shell = tq.TaskQueueShell()
[F8:198]|     
[F8:199]|     # Mock os.system 捕获 list 指令
[F8:200]|     with patch("os.system") as mock_system:
[F8:201]|         # 1. 测试 env list
[F8:202]|         shell.do_env("list")
[F8:203]|         mock_system.assert_called_with("conda env list")
[F8:204]|         
[F8:205]|         # 2. 测试 env activate my_env
[F8:206]|         shell.do_env("activate my_env")
[F8:207]|         assert shell.conda_env == "my_env"
[F8:208]|         
[F8:209]|         # 3. 测试 env short_cut
[F8:210]|         shell.do_env("short_cut")
[F8:211]|         assert shell.conda_env == "short_cut"
[F8:212]|         
[F8:213]|         # 4. 测试 env activate (无参数) -> 报错但不崩溃
[F8:214]|         # 我们捕获 stdout 来验证是否打印了 usage
[F8:215]|         from io import StringIO
[F8:216]|         captured_output = StringIO()
[F8:217]|         sys.stdout = captured_output
[F8:218]|         shell.do_env("activate")
[F8:219]|         sys.stdout = sys.__stdout__
[F8:220]|         assert "Usage" in captured_output.getvalue()
[F8:221]|         # 环境不应改变
[F8:222]|         assert shell.conda_env == "short_cut"

################################################################################
文件路径: tests/test_v5_7_features.py(F9) (约合大小: 7 KB)
################################################################################
[F9:1]| import os
[F9:2]| import pytest
[F9:3]| import time
[F9:4]| import subprocess
[F9:5]| import signal
[F9:6]| import shutil
[F9:7]| import sys
[F9:8]| from pathlib import Path
[F9:9]| 
[F9:10]| # --- 1. 路径获取与环境准备 (复用之前的稳健逻辑) ---
[F9:11]| def get_tq_paths():
[F9:12]|     tq_home = os.environ.get("TQ_HOME")
[F9:13]|     candidates = []
[F9:14]|     if tq_home: candidates.append(Path(tq_home))
[F9:15]|     current_dir = Path(__file__).parent.resolve()
[F9:16]|     candidates.append(current_dir)
[F9:17]|     candidates.append(current_dir.parent)
[F9:18]|     candidates.append(Path("."))
[F9:19]|     
[F9:20]|     for base in candidates:
[F9:21]|         sched = base / "scheduler.sh"
[F9:22]|         utils = base / "queue_utils.py"
[F9:23]|         if sched.exists() and utils.exists():
[F9:24]|             return str(sched), str(utils)
[F9:25]|             
[F9:26]|     raise FileNotFoundError("Could not find scheduler.sh AND queue_utils.py. Please set TQ_HOME.")
[F9:27]| 
[F9:28]| SCHEDULER_PATH, UTILS_PATH = get_tq_paths()
[F9:29]| 
[F9:30]| @pytest.fixture
[F9:31]| def workspace(tmp_path):
[F9:32]|     d = tmp_path / "task_queue"
[F9:33]|     d.mkdir()
[F9:34]|     logs = d / "logs"
[F9:35]|     logs.mkdir()
[F9:36]|     tasks_log = logs / "tasks"
[F9:37]|     tasks_log.mkdir()
[F9:38]| 
[F9:39]|     # 复制 queue_utils.py (必须，因为 scheduler.sh 依赖它)
[F9:40]|     shutil.copy(UTILS_PATH, d / "queue_utils.py")
[F9:41]|     os.chmod(d / "queue_utils.py", 0o755)
[F9:42]| 
[F9:43]|     # 修改 scheduler.sh 中的 BASE_DIR
[F9:44]|     with open(SCHEDULER_PATH, 'r') as f:
[F9:45]|         content = f.read()
[F9:46]|     content = content.replace('BASE_DIR="$HOME/task_queue"', f'BASE_DIR="{str(d)}"')
[F9:47]|     
[F9:48]|     test_scheduler = d / "scheduler_test.sh"
[F9:49]|     with open(test_scheduler, 'w') as f:
[F9:50]|         f.write(content)
[F9:51]|     os.chmod(test_scheduler, 0o755)
[F9:52]|     
[F9:53]|     return d, str(test_scheduler)
[F9:54]| 
[F9:55]| # --- 测试用例 ---
[F9:56]| 
[F9:57]| def test_running_file_format_and_header(workspace):
[F9:58]|     """
[F9:59]|     测试 v5.7 核心特性：
[F9:60]|     1. .running 文件是否为 6 行格式 (含 Tag)
[F9:61]|     2. 生成的 Log 文件是否包含 Metadata Header
[F9:62]|     3. 文件名是否经过安全过滤
[F9:63]|     """
[F9:64]|     base_dir, scheduler_script = workspace
[F9:65]|     queue_name = "tag_test"
[F9:66]|     
[F9:67]|     # 构造一个带特殊字符 Tag 的任务
[F9:68]|     # Tag: "experiment/v1" (应该被过滤为 experiment_v1)
[F9:69]|     tag_raw = "experiment/v1"
[F9:70]|     tag_safe = "experiment_v1"
[F9:71]|     cmd = "echo 'Hello Tag'"
[F9:72]|     
[F9:73]|     # 写入队列 (v5.7 格式: Prio:Grace:Tag:Cmd)
[F9:74]|     q_file = base_dir / f"{queue_name}.queue"
[F9:75]|     with open(q_file, 'w') as f:
[F9:76]|         f.write(f"100:180:{tag_raw}:{cmd}\n")
[F9:77]|         
[F9:78]|     # 启动调度器
[F9:79]|     proc = subprocess.Popen(
[F9:80]|         ["bash", scheduler_script, queue_name],
[F9:81]|         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
[F9:82]|         preexec_fn=os.setsid 
[F9:83]|     )
[F9:84]|     
[F9:85]|     try:
[F9:86]|         # 等待任务运行
[F9:87]|         start_time = time.time()
[F9:88]|         running_data = []
[F9:89]|         run_file = base_dir / f"{queue_name}.running"
[F9:90]|         
[F9:91]|         while time.time() - start_time < 5:
[F9:92]|             if run_file.exists():
[F9:93]|                 with open(run_file) as f:
[F9:94]|                     running_data = f.read().splitlines()
[F9:95]|                 if len(running_data) >= 6:
[F9:96]|                     break
[F9:97]|             time.sleep(0.5)
[F9:98]|             
[F9:99]|         # --- 验证 1: Running 文件格式 ---
[F9:100]|         assert len(running_data) == 6, f"Running file should have 6 lines, got {len(running_data)}"
[F9:101]|         # PID, Prio, Grace, Tag, LogPath, Cmd
[F9:102]|         assert running_data[1] == "100"      # Prio
[F9:103]|         assert running_data[3] == tag_raw    # Tag (原始值应保留在 running 文件中)
[F9:104]|         log_path = running_data[4]
[F9:105]|         assert running_data[5] == cmd        # Cmd
[F9:106]|         
[F9:107]|         # --- 验证 2: Log 文件名过滤 ---
[F9:108]|         assert tag_safe in os.path.basename(log_path), f"Log filename should contain safe tag '{tag_safe}'"
[F9:109]|         assert "/" not in os.path.basename(log_path) # 确保特殊字符被替换
[F9:110]|         
[F9:111]|         # --- 验证 3: Log Header ---
[F9:112]|         assert os.path.exists(log_path)
[F9:113]|         # 等待 flush
[F9:114]|         time.sleep(1)
[F9:115]|         with open(log_path, 'r') as f:
[F9:116]|             log_content = f.read()
[F9:117]|             
[F9:118]|         print(f"\n[Log Content Preview]\n{log_content}")
[F9:119]|         
[F9:120]|         assert "Task Metadata Log" in log_content
[F9:121]|         assert f"Tag        : {tag_raw}" in log_content
[F9:122]|         assert f"Command    : {cmd}" in log_content
[F9:123]|         assert "Hello Tag" in log_content # 确保真实输出也在
[F9:124]| 
[F9:125]|     finally:
[F9:126]|         os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
[F9:127]|         proc.wait()
[F9:128]| 
[F9:129]| def test_tag_persistence_after_preempt(workspace):
[F9:130]|     """
[F9:131]|     测试 v5.7 关键修复：
[F9:132]|     抢占发生后，Tag 应该保持原样，而不是变成 'preempted'
[F9:133]|     """
[F9:134]|     base_dir, scheduler_script = workspace
[F9:135]|     queue_name = "preempt_tag_test"
[F9:136]|     
[F9:137]|     # 1. 提交一个低优先级长任务 (Prio 100, Tag "MY_IMPORTANT_TAG")
[F9:138]|     original_tag = "MY_IMPORTANT_TAG"
[F9:139]|     # 使用 sleep 模拟长任务
[F9:140]|     cmd_low = "sleep 20"
[F9:141]|     
[F9:142]|     q_file = base_dir / f"{queue_name}.queue"
[F9:143]|     with open(q_file, 'w') as f:
[F9:144]|         f.write(f"100:5:{original_tag}:{cmd_low}\n")
[F9:145]|         
[F9:146]|     # 启动调度器
[F9:147]|     proc = subprocess.Popen(
[F9:148]|         ["bash", scheduler_script, queue_name],
[F9:149]|         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
[F9:150]|         preexec_fn=os.setsid 
[F9:151]|     )
[F9:152]|     
[F9:153]|     try:
[F9:154]|         # 等待低优先级任务运行
[F9:155]|         run_file = base_dir / f"{queue_name}.running"
[F9:156]|         time.sleep(2) 
[F9:157]|         assert run_file.exists()
[F9:158]|         
[F9:159]|         # 2. 提交一个高优先级任务 (Prio 1)
[F9:160]|         with open(q_file, 'a') as f:
[F9:161]|             f.write(f"1:5:urgent:echo urgent\n")
[F9:162]|             
[F9:163]|         # 等待抢占发生 (Running 文件变成 Prio 1 的任务，或者旧任务回到 Queue)
[F9:164]|         # 我们检测 Queue 文件是否重新出现了 Prio 100 的任务
[F9:165]|         preempted = False
[F9:166]|         requeued_line = ""
[F9:167]|         
[F9:168]|         start_wait = time.time()
[F9:169]|         while time.time() - start_wait < 10:
[F9:170]|             if q_file.exists():
[F9:171]|                 with open(q_file, 'r') as f:
[F9:172]|                     lines = f.readlines()
[F9:173]|                 # 找回 Prio 100 的任务
[F9:174]|                 for line in lines:
[F9:175]|                     if line.startswith("100:"):
[F9:176]|                         requeued_line = line.strip()
[F9:177]|                         preempted = True
[F9:178]|                         break
[F9:179]|             if preempted: break
[F9:180]|             time.sleep(1)
[F9:181]|             
[F9:182]|         assert preempted, "Task was not preempted/requeued."
[F9:183]|         
[F9:184]|         # --- 验证 4: Tag 保持不变 ---
[F9:185]|         # 期望格式: 100:Grace:MY_IMPORTANT_TAG:sleep 20
[F9:186]|         print(f"\n[Requeued Line] {requeued_line}")
[F9:187]|         parts = requeued_line.split(':')
[F9:188]|         assert len(parts) >= 4
[F9:189]|         assert parts[2] == original_tag, f"Tag changed! Expected '{original_tag}', got '{parts[2]}'"
[F9:190]|         assert parts[2] != "preempted", "Tag was wrongly overwritten by 'preempted' state"
[F9:191]| 
[F9:192]|     finally:
[F9:193]|         os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
[F9:194]|         proc.wait()
[F9:195]| 
[F9:196]| def test_queue_utils_locking(workspace):
[F9:197]|     """
[F9:198]|     简单测试 queue_utils.py 的 pop 功能是否正常
[F9:199]|     (真正的并发锁测试很难在单元测试中模拟，这里主要测试基本调用链路)
[F9:200]|     """
[F9:201]|     base_dir, _ = workspace
[F9:202]|     utils_script = base_dir / "queue_utils.py"
[F9:203]|     q_file = base_dir / "lock_test.queue"
[F9:204]|     
[F9:205]|     # 准备数据
[F9:206]|     with open(q_file, 'w') as f:
[F9:207]|         f.write("100:180:tag1:cmd1\n")
[F9:208]|         f.write("10:180:tag2:cmd2\n") # Prio 10 更高
[F9:209]|         f.write("50:180:tag3:cmd3\n")
[F9:210]|         
[F9:211]|     # 调用 pop
[F9:212]|     result = subprocess.check_output(
[F9:213]|         ["python3", str(utils_script), "pop", str(q_file)], 
[F9:214]|         text=True
[F9:215]|     ).strip()
[F9:216]|     
[F9:217]|     # 验证弹出的是 Prio 10
[F9:218]|     assert "tag2" in result
[F9:219]|     assert "cmd2" in result
[F9:220]|     
[F9:221]|     # 验证文件剩余内容
[F9:222]|     with open(q_file, 'r') as f:
[F9:223]|         content = f.read()
[F9:224]|     assert "tag2" not in content
[F9:225]|     assert "tag1" in content
[F9:226]|     assert "tag3" in content

################################################################################
文件路径: tests/test_grace_logging.py(F10) (约合大小: 5 KB)
################################################################################
[F10:1]| import os
[F10:2]| import pytest
[F10:3]| import time
[F10:4]| import subprocess
[F10:5]| import signal
[F10:6]| import sys
[F10:7]| import shutil
[F10:8]| from pathlib import Path
[F10:9]| 
[F10:10]| # --- 1. 智能查找路径 ---
[F10:11]| def get_tq_paths():
[F10:12]|     tq_home = os.environ.get("TQ_HOME")
[F10:13]|     candidates = []
[F10:14]|     if tq_home: candidates.append(Path(tq_home))
[F10:15]|     
[F10:16]|     current_dir = Path(__file__).parent.resolve()
[F10:17]|     candidates.append(current_dir)          # tests/
[F10:18]|     candidates.append(current_dir.parent)   # root/
[F10:19]|     candidates.append(Path("."))            # cwd
[F10:20]|     
[F10:21]|     for base in candidates:
[F10:22]|         sched = base / "scheduler.sh"
[F10:23]|         utils = base / "queue_utils.py"
[F10:24]|         if sched.exists() and utils.exists():
[F10:25]|             return str(sched), str(utils)
[F10:26]|             
[F10:27]|     raise FileNotFoundError("Could not find scheduler.sh AND queue_utils.py. Please set TQ_HOME.")
[F10:28]| 
[F10:29]| SCHEDULER_PATH, UTILS_PATH = get_tq_paths()
[F10:30]| 
[F10:31]| @pytest.fixture
[F10:32]| def workspace(tmp_path):
[F10:33]|     d = tmp_path / "task_queue"
[F10:34]|     d.mkdir()
[F10:35]|     logs = d / "logs"
[F10:36]|     logs.mkdir()
[F10:37]|     tasks_log = logs / "tasks"
[F10:38]|     tasks_log.mkdir()
[F10:39]| 
[F10:40]|     # 复制依赖文件 queue_utils.py
[F10:41]|     shutil.copy(UTILS_PATH, d / "queue_utils.py")
[F10:42]|     os.chmod(d / "queue_utils.py", 0o755)
[F10:43]| 
[F10:44]|     # 修改 scheduler.sh 中的 BASE_DIR
[F10:45]|     with open(SCHEDULER_PATH, 'r') as f:
[F10:46]|         content = f.read()
[F10:47]|     
[F10:48]|     content = content.replace('BASE_DIR="$HOME/task_queue"', f'BASE_DIR="{str(d)}"')
[F10:49]|     
[F10:50]|     test_scheduler = d / "scheduler_test.sh"
[F10:51]|     with open(test_scheduler, 'w') as f:
[F10:52]|         f.write(content)
[F10:53]|     
[F10:54]|     os.chmod(test_scheduler, 0o755)
[F10:55]|     
[F10:56]|     return d, str(test_scheduler)
[F10:57]| 
[F10:58]| # --- 模拟任务脚本 ---
[F10:59]| SIMULATED_TASK_SCRIPT = """
[F10:60]| import time
[F10:61]| import signal
[F10:62]| import sys
[F10:63]| import os
[F10:64]| 
[F10:65]| save_duration = int(sys.argv[1]) if len(sys.argv) > 1 else 5
[F10:66]| print(f"[Task] Started with PID: {os.getpid()}. Will simulate save for {save_duration}s on SIGTERM.")
[F10:67]| 
[F10:68]| stop_requested = False
[F10:69]| def signal_handler(signum, frame):
[F10:70]|     global stop_requested
[F10:71]|     print(f"\\n[Task] Received signal {signum}. Initiating graceful shutdown (saving for {save_duration}s)...", flush=True)
[F10:72]|     stop_requested = True
[F10:73]|     time.sleep(save_duration)
[F10:74]|     print("[Task] Save complete. Exiting.", flush=True)
[F10:75]|     sys.exit(0)
[F10:76]| 
[F10:77]| signal.signal(signal.SIGTERM, signal_handler)
[F10:78]| 
[F10:79]| epoch = 0
[F10:80]| while not stop_requested:
[F10:81]|     print(f"[Task] Epoch {epoch} processing...", flush=True)
[F10:82]|     time.sleep(1)
[F10:83]|     epoch += 1
[F10:84]|     if epoch > 30: break
[F10:85]| """
[F10:86]| 
[F10:87]| def test_graceful_shutdown_and_logging(workspace):
[F10:88]|     base_dir, scheduler_script = workspace
[F10:89]|     queue_name = "grace_test"
[F10:90]|     grace_period = 3  # 加快测试速度
[F10:91]|     
[F10:92]|     # 1. 创建模拟脚本
[F10:93]|     sim_task_file = base_dir / "sim_task.py"
[F10:94]|     with open(sim_task_file, 'w') as f:
[F10:95]|         f.write(SIMULATED_TASK_SCRIPT)
[F10:96]|         
[F10:97]|     # 2. 提交任务
[F10:98]|     task_cmd = f"python {sim_task_file} {grace_period}"
[F10:99]|     q_file = base_dir / f"{queue_name}.queue"
[F10:100]|     with open(q_file, 'w') as f:
[F10:101]|         f.write(f"100:{grace_period}:{task_cmd}\n")
[F10:102]|         
[F10:103]|     # 3. 启动调度器
[F10:104]|     proc = subprocess.Popen(
[F10:105]|         ["bash", scheduler_script, queue_name],
[F10:106]|         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
[F10:107]|         preexec_fn=os.setsid 
[F10:108]|     )
[F10:109]|     
[F10:110]|     preempt_proc = None
[F10:111]| 
[F10:112]|     try:
[F10:113]|         # 等待启动 (轮询 .running 文件)
[F10:114]|         start_time = time.time()
[F10:115]|         pid = -1
[F10:116]|         log_path = ""
[F10:117]|         run_file = base_dir / f"{queue_name}.running"
[F10:118]|         
[F10:119]|         while time.time() - start_time < 5:
[F10:120]|             if run_file.exists():
[F10:121]|                 try:
[F10:122]|                     with open(run_file) as f:
[F10:123]|                         lines = f.read().splitlines()
[F10:124]|                         # --- 修复点：适配 v5.7 的 6 行格式 ---
[F10:125]|                         if len(lines) >= 6:
[F10:126]|                             pid = int(lines[0])
[F10:127]|                             # Index 0: PID, 1: Prio, 2: Grace, 3: Tag, 4: LogPath, 5: Cmd
[F10:128]|                             log_path = lines[4] 
[F10:129]|                             break
[F10:130]|                         # 兼容旧版本测试逻辑（防止回滚代码时测试全崩）
[F10:131]|                         elif len(lines) >= 5:
[F10:132]|                             pid = int(lines[0])
[F10:133]|                             log_path = lines[3]
[F10:134]|                             break
[F10:135]|                 except: pass
[F10:136]|             time.sleep(0.5)
[F10:137]|             
[F10:138]|         assert pid != -1, f"Task failed to start. Scheduler log: {base_dir}/logs/scheduler_{queue_name}.log"
[F10:139]|         
[F10:140]|         # 4. 抢占测试
[F10:141]|         with open(q_file, 'a') as f:
[F10:142]|             f.write(f"1:0:echo 'Priority Task'\n")
[F10:143]|             
[F10:144]|         interrupted = False
[F10:145]|         wait_start = time.time()
[F10:146]|         while time.time() - wait_start < 10:
[F10:147]|             if not run_file.exists():
[F10:148]|                 interrupted = True
[F10:149]|                 break
[F10:150]|             else:
[F10:151]|                 try:
[F10:152]|                     with open(run_file) as f:
[F10:153]|                         new_pid = int(f.readline().strip())
[F10:154]|                     if new_pid != pid:
[F10:155]|                         interrupted = True
[F10:156]|                         break
[F10:157]|                 except: pass
[F10:158]|             time.sleep(1)
[F10:159]|             
[F10:160]|         assert interrupted, "Original task was not pre-empted."
[F10:161]|         
[F10:162]|         # 5. 验证日志
[F10:163]|         # 这里 log_path 应该是真实路径，不再是 "default"
[F10:164]|         assert os.path.exists(log_path), f"Log file not found at: {log_path}"
[F10:165]|         
[F10:166]|         time.sleep(1)
[F10:167]|         with open(log_path, 'r') as f:
[F10:168]|             content = f.read()
[F10:169]|             assert "Received signal" in content or "Starting" in content
[F10:170]| 
[F10:171]|     finally:
[F10:172]|         if proc.poll() is None:
[F10:173]|             os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
[F10:174]|             proc.wait()
[F10:175]|         
[F10:176]|         if preempt_proc and preempt_proc.poll() is None:
[F10:177]|             preempt_proc.terminate()
[F10:178]|             preempt_proc.wait()

## 统计信息
- 包含文件数: 10
- 总大小: 46 KB